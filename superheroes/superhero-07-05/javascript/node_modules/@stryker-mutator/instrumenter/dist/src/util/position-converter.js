/**
 * A class that can convert a string offset back to line / column.
 * Grabbed from TypeScript code base
 * @see https://github.com/microsoft/TypeScript/blob/aa9b6953441b53f8b14072c047f0519b611150c4/src/compiler/scanner.ts#L503
 */
export class PositionConverter {
    text;
    _lineStarts;
    get lineStarts() {
        if (!this._lineStarts) {
            this._lineStarts = this.computeLineStarts(this.text);
        }
        return this._lineStarts;
    }
    constructor(text) {
        this.text = text;
    }
    positionFromOffset(offset) {
        const lineNumber = this.computeLineOfPosition(offset);
        return {
            line: lineNumber,
            column: offset - this.lineStarts[lineNumber],
        };
    }
    computeLineOfPosition(offset) {
        let lineNumber = binarySearch(this.lineStarts, offset);
        if (lineNumber < 0) {
            // If the actual position was not found,
            // the binary search returns the 2's-complement of the next line start
            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
            // then the search will return -2.
            //
            // We want the index of the previous line start, so we subtract 1.
            // Review 2's-complement if this is confusing.
            lineNumber = ~lineNumber - 1;
            if (lineNumber === -1) {
                throw new Error('position cannot precede the beginning of the file');
            }
        }
        return lineNumber;
    }
    computeLineStarts(text) {
        const result = [];
        let pos = 0;
        let lineStart = 0;
        while (pos < text.length) {
            const ch = text.charCodeAt(pos);
            pos++;
            switch (ch) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
                case 13 /* CharacterCodes.carriageReturn */: {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
                    if (text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {
                        pos++;
                    }
                    // falls through
                }
                // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
                case 10 /* CharacterCodes.lineFeed */:
                    result.push(lineStart);
                    lineStart = pos;
                    break;
                default:
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
                    if (ch > 127 /* CharacterCodes.maxAsciiCharacter */ && isLineBreak(ch)) {
                        result.push(lineStart);
                        lineStart = pos;
                    }
                    break;
            }
        }
        result.push(lineStart);
        return result;
    }
}
function binarySearch(array, value) {
    if (!array.length) {
        return -1;
    }
    let low = 0;
    let high = array.length - 1;
    while (low <= high) {
        const middle = low + ((high - low) >> 1);
        const midKey = compare(array[middle], value);
        switch (midKey) {
            case -1 /* Comparison.LessThan */:
                low = middle + 1;
                break;
            case 0 /* Comparison.EqualTo */:
                return middle;
            case 1 /* Comparison.GreaterThan */:
                high = middle - 1;
                break;
        }
    }
    return ~low;
}
function compare(a, b) {
    return a < b ? -1 /* Comparison.LessThan */ : a > b ? 1 /* Comparison.GreaterThan */ : 0 /* Comparison.EqualTo */;
}
function isLineBreak(ch) {
    // ES5 7.3:
    // The ECMAScript line terminator characters are listed in Table 3.
    //     Table 3: Line Terminator Characters
    //     Code Unit Value     Name                    Formal Name
    //     \u000A              Line Feed               <LF>
    //     \u000D              Carriage Return         <CR>
    //     \u2028              Line separator          <LS>
    //     \u2029              Paragraph separator     <PS>
    // Only the characters in Table 3 are treated as line terminators. Other new line or line
    // breaking characters are treated as white space but not as line terminators.
    return (
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    ch === 10 /* CharacterCodes.lineFeed */ ||
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        ch === 13 /* CharacterCodes.carriageReturn */ ||
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        ch === 8232 /* CharacterCodes.lineSeparator */ ||
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        ch === 8233 /* CharacterCodes.paragraphSeparator */);
}
//# sourceMappingURL=position-converter.js.map