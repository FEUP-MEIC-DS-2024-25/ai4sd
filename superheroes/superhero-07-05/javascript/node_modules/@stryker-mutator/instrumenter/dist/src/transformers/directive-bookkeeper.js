import { notEmpty } from '@stryker-mutator/util';
const WILDCARD = 'all';
const DEFAULT_REASON = 'Ignored using a comment';
class IgnoreRule {
    mutatorNames;
    line;
    ignoreReason;
    previousRule;
    constructor(mutatorNames, line, ignoreReason, previousRule) {
        this.mutatorNames = mutatorNames;
        this.line = line;
        this.ignoreReason = ignoreReason;
        this.previousRule = previousRule;
    }
    matches(mutatorName, line) {
        const lineMatches = () => this.line === undefined || this.line === line;
        const mutatorMatches = () => this.mutatorNames.includes(mutatorName) || this.mutatorNames.includes(WILDCARD);
        return lineMatches() && mutatorMatches();
    }
    findIgnoreReason(mutatorName, line) {
        if (this.matches(mutatorName, line)) {
            return this.ignoreReason;
        }
        return this.previousRule.findIgnoreReason(mutatorName, line);
    }
}
class RestoreRule extends IgnoreRule {
    constructor(mutatorNames, line, previousRule) {
        super(mutatorNames, line, undefined, previousRule);
    }
}
const rootRule = {
    findIgnoreReason() {
        return undefined;
    },
};
/**
 * Responsible for the bookkeeping of "// Stryker" directives like "disable" and "restore".
 */
export class DirectiveBookkeeper {
    logger;
    allMutators;
    originFileName;
    // https://regex101.com/r/nWLLLm/1
    strykerCommentDirectiveRegex = /^\s?Stryker (disable|restore)(?: (next-line))? ([a-zA-Z, ]+)(?::(.+)?)?/;
    currentIgnoreRule = rootRule;
    allMutatorNames;
    constructor(logger, allMutators, originFileName) {
        this.logger = logger;
        this.allMutators = allMutators;
        this.originFileName = originFileName;
        this.allMutatorNames = this.allMutators.map((x) => x.name.toLowerCase());
    }
    processStrykerDirectives({ loc, leadingComments }) {
        leadingComments
            ?.map((comment) => ({
            comment,
            matchResult: this.strykerCommentDirectiveRegex.exec(comment.value),
        }))
            .filter(({ matchResult }) => notEmpty(matchResult))
            .forEach(({ comment, matchResult }) => {
            const [, directiveType, scope, mutators, optionalReason] = matchResult;
            let mutatorNames = mutators.split(',').map((mutator) => mutator.trim());
            this.warnAboutUnusedDirective(mutatorNames, directiveType, scope, comment);
            mutatorNames = mutatorNames.map((mutator) => mutator.toLowerCase());
            const reason = (optionalReason ?? DEFAULT_REASON).trim();
            switch (directiveType) {
                case 'disable':
                    switch (scope) {
                        case 'next-line':
                            this.currentIgnoreRule = new IgnoreRule(mutatorNames, loc.start.line, reason, this.currentIgnoreRule);
                            break;
                        default:
                            this.currentIgnoreRule = new IgnoreRule(mutatorNames, undefined, reason, this.currentIgnoreRule);
                            break;
                    }
                    break;
                case 'restore':
                    switch (scope) {
                        case 'next-line':
                            this.currentIgnoreRule = new RestoreRule(mutatorNames, loc.start.line, this.currentIgnoreRule);
                            break;
                        default:
                            this.currentIgnoreRule = new RestoreRule(mutatorNames, undefined, this.currentIgnoreRule);
                            break;
                    }
                    break;
            }
        });
    }
    findIgnoreReason(line, mutatorName) {
        mutatorName = mutatorName.toLowerCase();
        return this.currentIgnoreRule.findIgnoreReason(mutatorName, line);
    }
    warnAboutUnusedDirective(mutators, directiveType, scope, comment) {
        for (const mutator of mutators) {
            if (mutator === WILDCARD)
                continue;
            if (!this.allMutatorNames.includes(mutator.toLowerCase())) {
                this.logger.warn(
                // Scope can be global and therefore undefined
                `Unused 'Stryker ${scope ? directiveType + ' ' + scope : directiveType}' directive. Mutator with name '${mutator}' not found. Directive found at: ${this.originFileName}:${comment.loc.start.line}:${comment.loc.start.column}.`);
            }
        }
    }
}
//# sourceMappingURL=directive-bookkeeper.js.map