import { TestRunnerDecorator } from './test-runner-decorator.js';
var TestEnvironmentState;
(function (TestEnvironmentState) {
    TestEnvironmentState[TestEnvironmentState["Pristine"] = 0] = "Pristine";
    TestEnvironmentState[TestEnvironmentState["Loaded"] = 1] = "Loaded";
    TestEnvironmentState[TestEnvironmentState["LoadedStaticMutant"] = 2] = "LoadedStaticMutant";
})(TestEnvironmentState || (TestEnvironmentState = {}));
export class ReloadEnvironmentDecorator extends TestRunnerDecorator {
    _capabilities;
    testEnvironment = TestEnvironmentState.Pristine;
    async capabilities() {
        if (!this._capabilities) {
            this._capabilities = await super.capabilities();
        }
        return this._capabilities;
    }
    async dryRun(options) {
        this.testEnvironment = TestEnvironmentState.Loaded;
        return super.dryRun(options);
    }
    async mutantRun(options) {
        let newState;
        if (options.reloadEnvironment) {
            newState = TestEnvironmentState.LoadedStaticMutant;
            // If env is still pristine (first run), no reload is actually needed
            options.reloadEnvironment = this.testEnvironment !== TestEnvironmentState.Pristine;
            if (options.reloadEnvironment && !(await this.testRunnerIsCapableOfReload())) {
                await this.recover();
                options.reloadEnvironment = false;
            }
        }
        else {
            // Reload might still be needed actually, since a static mutant could be loaded
            newState = TestEnvironmentState.Loaded;
            if (this.testEnvironment === TestEnvironmentState.LoadedStaticMutant) {
                // Test env needs reloading
                if (await this.testRunnerIsCapableOfReload()) {
                    options.reloadEnvironment = true;
                }
                else {
                    // loaded a static mutant in previous run, need to reload first
                    await this.recover();
                }
            }
        }
        const result = await super.mutantRun(options);
        this.testEnvironment = newState;
        return result;
    }
    async testRunnerIsCapableOfReload() {
        return (await this.capabilities()).reloadEnvironment;
    }
}
//# sourceMappingURL=reload-environment-decorator.js.map