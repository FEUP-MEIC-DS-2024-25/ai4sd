import { commonTokens } from '@stryker-mutator/api/plugin';
import { notEmpty } from '@stryker-mutator/util';
import { coreTokens } from '../di/index.js';
export class TestCoverage {
    #testsByMutantId;
    #testsById;
    #staticCoverage;
    #hitsByMutantId;
    constructor(testsByMutantId, testsById, staticCoverage, hitsByMutantId) {
        this.#testsByMutantId = testsByMutantId;
        this.#testsById = testsById;
        this.#staticCoverage = staticCoverage;
        this.#hitsByMutantId = hitsByMutantId;
    }
    get testsByMutantId() {
        return this.#testsByMutantId;
    }
    get testsById() {
        return this.#testsById;
    }
    get hitsByMutantId() {
        return this.#hitsByMutantId;
    }
    get hasCoverage() {
        // Since static coverage should always be reported when coverage analysis succeeded (albeit an empty object),
        // we can use that to determine if there is any coverage at all
        return !!this.#staticCoverage;
    }
    hasStaticCoverage(mutantId) {
        return !!(this.#staticCoverage && this.#staticCoverage[mutantId] > 0);
    }
    addTest(testResult) {
        this.#testsById.set(testResult.id, testResult);
    }
    addCoverage(mutantId, testIds) {
        const tests = this.#testsByMutantId.get(mutantId) ?? new Set();
        this.#testsByMutantId.set(mutantId, tests);
        testIds
            .map((testId) => this.#testsById.get(testId))
            .filter(notEmpty)
            .forEach((test) => tests.add(test));
    }
    forMutant(mutantId) {
        return this.#testsByMutantId.get(mutantId);
    }
    static from = testCoverageFrom;
}
function testCoverageFrom({ tests, mutantCoverage }, logger) {
    const hitsByMutantId = new Map();
    const testsByMutantId = new Map();
    const testsById = tests.reduce((acc, test) => acc.set(test.id, test), new Map());
    if (mutantCoverage) {
        Object.entries(mutantCoverage.perTest).forEach(([testId, coverage]) => {
            const foundTest = testsById.get(testId);
            if (!foundTest) {
                logger.warn(`Found test with id "${testId}" in coverage data, but not in the test results of the dry run. Not taking coverage data for this test into account.`);
                return;
            }
            Object.entries(coverage).forEach(([mutantId, count]) => {
                if (count > 0) {
                    let cov = testsByMutantId.get(mutantId);
                    if (!cov) {
                        cov = new Set();
                        testsByMutantId.set(mutantId, cov);
                    }
                    cov.add(foundTest);
                }
            });
        });
        // We don't care about the exact tests in this case, just the total number of hits
        const coverageResultsPerMutant = [mutantCoverage.static, ...Object.values(mutantCoverage.perTest)];
        coverageResultsPerMutant.forEach((coverageByMutantId) => {
            Object.entries(coverageByMutantId).forEach(([mutantId, count]) => {
                hitsByMutantId.set(mutantId, (hitsByMutantId.get(mutantId) ?? 0) + count);
            });
        });
    }
    return new TestCoverage(testsByMutantId, testsById, mutantCoverage?.static, hitsByMutantId);
}
testCoverageFrom.inject = [coreTokens.dryRunResult, commonTokens.logger];
//# sourceMappingURL=test-coverage.js.map