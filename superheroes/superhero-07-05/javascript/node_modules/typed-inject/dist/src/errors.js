/*

                    ┏━━━━━━━━━━━━━━━━━━┓
                    ┃ TypedInjectError ┃
                    ┗━━━━━━━━━━━━━━━━━━┛
                              ▲
                              ┃
               ┏━━━━━━━━━━━━━━┻━━━━━━━━━━━━━┓
               ┃                            ┃
 ┏━━━━━━━━━━━━━┻━━━━━━━━━━┓        ┏━━━━━━━━┻━━━━━━━┓
 ┃ InjectorDisposedError  ┃        ┃ InjectionError ┃
 ┗━━━━━━━━━━━━━━━━━━━━━━━━┛        ┗━━━━━━━━━━━━━━━━┛
*/
export class TypedInjectError extends Error {
}
function describeInjectAction(target) {
    if (typeof target === 'function') {
        return 'inject';
    }
    else {
        return 'resolve';
    }
}
function name(target) {
    if (typeof target === 'function') {
        if (target.toString().startsWith('class')) {
            return `[class ${target.name || '<anonymous>'}]`;
        }
        else {
            return `[function ${target.name || '<anonymous>'}]`;
        }
    }
    else {
        return `[token "${String(target)}"]`;
    }
}
export class InjectorDisposedError extends TypedInjectError {
    constructor(target) {
        super(`Injector is already disposed. Please don't use it anymore. Tried to ${describeInjectAction(target)} ${name(target)}.`);
    }
}
export class InjectionError extends TypedInjectError {
    constructor(path, cause) {
        super(`Could not ${describeInjectAction(path[0])} ${path.map(name).join(' -> ')}. Cause: ${cause.message}`);
        this.path = path;
        this.cause = cause;
    }
    static create(target, error) {
        if (error instanceof InjectionError) {
            return new InjectionError([target, ...error.path], error.cause);
        }
        else {
            return new InjectionError([target], error);
        }
    }
}
//# sourceMappingURL=errors.js.map