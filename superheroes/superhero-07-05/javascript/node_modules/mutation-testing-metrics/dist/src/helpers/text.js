/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */
// The implementation of this file is grabbed and modified from TypeScript source code
var CharacterCodes;
(function (CharacterCodes) {
    CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
    CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
    CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
    CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
    CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
})(CharacterCodes || (CharacterCodes = {}));
function isLineBreak(ch) {
    // ES5 7.3:
    // The ECMAScript line terminator characters are listed in Table 3.
    //     Table 3: Line Terminator Characters
    //     Code Unit Value     Name                    Formal Name
    //     \u000A              Line Feed               <LF>
    //     \u000D              Carriage Return         <CR>
    //     \u2028              Line separator          <LS>
    //     \u2029              Paragraph separator     <PS>
    // Only the characters in Table 3 are treated as line terminators. Other new line or line
    // breaking characters are treated as white space but not as line terminators.
    return (ch === CharacterCodes.lineFeed ||
        ch === CharacterCodes.carriageReturn ||
        ch === CharacterCodes.lineSeparator ||
        ch === CharacterCodes.paragraphSeparator);
}
export function computeLineStarts(text) {
    const result = [];
    let pos = 0;
    let lineStart = 0;
    function progressLineStart(pos) {
        result.push(lineStart);
        lineStart = pos;
    }
    // Mutation testing elements works with 1-based lines
    progressLineStart(0);
    while (pos < text.length) {
        const ch = text.charCodeAt(pos);
        pos++;
        switch (ch) {
            case CharacterCodes.carriageReturn:
                if (text.charCodeAt(pos) === CharacterCodes.lineFeed) {
                    pos++;
                }
                progressLineStart(pos);
                break;
            case CharacterCodes.lineFeed:
                progressLineStart(pos);
                break;
            default:
                if (ch > CharacterCodes.maxAsciiCharacter && isLineBreak(ch)) {
                    progressLineStart(pos);
                }
                break;
        }
    }
    result.push(lineStart);
    return result;
}
//# sourceMappingURL=text.js.map