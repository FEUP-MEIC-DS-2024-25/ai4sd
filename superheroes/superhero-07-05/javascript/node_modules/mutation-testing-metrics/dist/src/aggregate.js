import { determineCommonBasePath, isNotNullish, normalizeFileNames } from './helpers/index.js';
/**
 * Aggregates multiple reports together into a single report, grouped by module.
 *
 * @param resultsByModule The MutationTestResult objects by module name
 * @returns An aggregated result of all provided reports.
 */
export function aggregateResultsByModule(resultsByModule) {
    const projectRoots = Object.values(resultsByModule)
        .map((report) => report.projectRoot)
        .filter(isNotNullish);
    const aggregatedResult = {
        files: {},
        schemaVersion: '1.7',
        thresholds: resultsByModule[0]?.thresholds ?? { high: 80, low: 60 },
        projectRoot: projectRoots.length ? determineCommonBasePath(projectRoots) : undefined,
        config: {},
    };
    return Object.entries(resultsByModule).reduce((acc, [moduleName, report]) => {
        Object.entries(normalizeFileNames(report.files)).forEach(([fileName, fileResult]) => {
            aggregatedResult.files[`${moduleName}/${fileName}`] = {
                ...fileResult,
                mutants: [
                    ...fileResult.mutants.map(({ id, coveredBy, killedBy, ...mutantData }) => ({
                        ...mutantData,
                        id: toUniqueId(moduleName, id),
                        killedBy: toUniqueIds(moduleName, killedBy),
                        coveredBy: toUniqueIds(moduleName, coveredBy),
                    })),
                ],
            };
        });
        if (report.testFiles) {
            const aggregatedTestFiles = aggregatedResult.testFiles ?? (aggregatedResult.testFiles = Object.create(null));
            Object.entries(normalizeFileNames(report.testFiles)).forEach(([fileName, testFileResult]) => {
                aggregatedTestFiles[`${moduleName}/${fileName}`] = {
                    ...testFileResult,
                    tests: testFileResult.tests.map(({ id, ...testData }) => ({ ...testData, id: toUniqueId(moduleName, id) })),
                };
            });
        }
        return acc;
    }, aggregatedResult);
}
function toUniqueIds(moduleName, localIds) {
    if (localIds) {
        const toUniqueIdForModule = toUniqueId.bind(undefined, moduleName);
        return localIds.map(toUniqueIdForModule);
    }
    return;
}
function toUniqueId(moduleName, localId) {
    return `${moduleName}_${localId}`;
}
//# sourceMappingURL=aggregate.js.map